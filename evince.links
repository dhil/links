## Doodle-like thingie
## Written by Daniel HillerstrÃ¶m (daniel.hillerstrom@ed.ac.uk), April 2019.

##
## Utilities
##
sig isAsciiLetter : (Char) -> Bool
fun isAsciiLetter(c) {
  var c = ord(c);
  (ord('a') <= c && c <= ord('z')) || (ord('A') <= c && c <= ord('Z'))
}

sig isSpace : (Char) -> Bool
fun isSpace(c) { ord(c) == ord(' ') }

sig isValidName : (String) ~> Bool
fun isValidName(name) {
  all(fun(c) { isAsciiLetter(c) || isSpace(c) }, explode(name))
}

##
## Reader interface
##
sig reader : (s, Comp({Ask:s |e}, a)) -> Comp({ |e}, a)
fun reader(item, m) {
  (fun() {
    handle(m()) {
      case Ask(resume) -> resume(item)
    }
  } : (Comp({ |e}, a)) <- (Comp({Ask- |e}, a))) # .. this is just.. well.. broken.
}

sig ask : () {Ask:a |_}-> a
fun ask() {do Ask}

##
## Exception interface
##
sig fail : () {Fail:Zero |_}~> a
fun fail() {switch(do Fail) { }}

sig maybe : (Comp({Fail:Zero |e}, a)) -> Comp({ |e}, Maybe(a))
fun maybe(m) {
  (fun() {
    handle(m()) {
      case Return(x) -> Just(x)
      case Fail      -> Nothing
    }
  } : (Comp({ |e}, Maybe(a))) <- (Comp({Fail- |e}, Maybe(a))))
}

sig lookup : (a, [(a, b)]) {Fail:Zero |_}~> b
fun lookup(x, xs) {
  switch (xs) {
    case [] -> fail()
    case (y, z) :: xs ->
      if (x == y) z else lookup(x, xs)
  }
}

##
## Server API
##
typename ProtoEvent(a) = (id:String,name:String,done:a,date:String,created:String);
typename RawEvent = ProtoEvent(Int);
typename Event = ProtoEvent(Bool);
typename NewEvent = (name:String);

typename ProtoRegistrant(e::Row) = (id:Int,event:String,dietary:String,timestamp:String,name:String);
typename RawRegistrant = ProtoRegistrant({ });
typename Registrant = ProtoRegistrant({event-});
typename NewRegistrant = (name:String,dietary:String);

typename Config = (events: () {}~> TableHandle(RawEvent, RawEvent, RawEvent),
                   registrants: () {}~> TableHandle(RawRegistrant, RawRegistrant, RawRegistrant));

sig makeConfig : (String) ~> Config
fun makeConfig(dbname) server {
  (events = fun() {
     table "events" with (id:String,name:String,done:Int,date:String,created:String)
     from database dbname
   },
   registrants = fun() {
     table "registrants" with (id:Int,event:String,name:String,dietary:String,timestamp:String)
     from database dbname
   })
}


sig getEvent : (String) {Ask:Config, Fail:Zero |_}~> Event
fun getEvent(id) server {
  var config = ask();
  var events = gen0(config.events)();
  var results = query {
     for (event <-- events)
     where (event.id == id)
     [event]
  };

  switch (results) {
    case [event] ->
      (id=event.id, name=event.name, done = (event.done <> 0), date=event.date, created = event.created)
    case _ -> fail()
  }
}

sig addRegistrant : (Event, NewRegistrant) {Ask:Config, Fail:Zero |_}~> ()
fun addRegistrant(ev, x) server { () }

sig deleteRegistrant : (Registrant) {Ask:Config, Fail:Zero |_}~> ()
fun deleteRegistrant(x) server { () }

sig getRegistrant : (Int) {Ask:Config, Fail:Zero |_}~> Registrant
fun getRegistrant(id) server {
  var config = ask();
  var registrants = gen0(config.registrants)();
  var results = query {
    for (registrant <-- registrants)
    where (registrant.id == id)
    [registrant]
  };

  switch (results) {
    case [registrant] -> registrant
    case _ -> fail()
  }
}

sig getRegistrants : (Event) {Ask:Config |_}~> [Registrant]
fun getRegistrants(ev) server {
  var config = ask();
  var registrants = gen0(config.registrants)();
  query {
     for (registrant <-- registrants)
     where (registrant.event == ev.id)
     orderby (registrant.id)
     [registrant]
  }
}

# typename RegisterService = [&|Add:?(NewRegistrant, Int).![|OK|].End,
#                               Delete:?Int.![|OK|].End|&];
#                               # Get:?Int.![Registrant].End|&];
# sig registerService : (AP(RegisterService)) ~%~> _
# fun registerService(ap) server {
#   var ch = accept(ap);
#   ignore(offer(ch) {
#     case Add(ch) ->
#       var ((data, eventId), ch) = receive(ch);
#       addRegistrant(getEvent(eventId), data);
#       close(send(OK, ch))
#     case Delete(ch) ->
#       var (regId, ch) = receive(ch);
#       deleteRegistrant(getRegistrant(regId));
#       close(send(OK, ch))
#     # case Get(ch) ->
#     #   var (eventId, ch) = receive(ch);
#     #   close(send(getRegistrants(getEvent(eventId)), ch))
#   });
#   registerService(ap)
# }

##
## Front end utilities
##
sig strsplit : (Char, String) ~> [String]
fun strsplit(delim, s) server {
  fun strsplit_aux(cs, acc) {
    switch (cs) {
      case [] -> reverse(map(reverse, acc))
      case c :: cs ->
        if (c == delim) strsplit_aux(cs, [] :: acc)
        else switch (acc) {
             case ks :: kss -> strsplit_aux(cs, (c :: ks) :: kss)
        }
    }
  }
  map(implode, strsplit_aux(explode(s), [[]]))
}

sig formatDate : (String) ~> String
fun formatDate(date) {
  fun month(m) {
    switch (stringToInt(m)) {
      case 1 -> "January"
      case 2 -> "February"
      case 3 -> "March"
      case 4 -> "April"
      case 5 -> "May"
      case 6 -> "June"
      case 7 -> "July"
      case 8 -> "August"
      case 9 -> "September"
      case 10 -> "October"
      case 11 -> "November"
      case 12 -> "December"
      case _  -> error("bad input")
    }
  }
  var components = strsplit('-', date);
  switch (components) {
    case [y, m, d] ->
      month(m) ^^ " " ^^ d ^^ ", " ^^ y
    case _ -> error("bad input")
  }
}


##
## Pages
##

sig textarea : () ~> Formlet (String)
fun textarea() {
  mkInput(fun (name) { <textarea name="{name}"></textarea> },
          fun (name,value) { <textarea name="{name}">{stringToXml(value)}</textarea> })
}

sig registerForm : (String) ~> Formlet(%)
fun registerForm(eventId) server {
  formlet
    <#>
      { inputA([("style", "display:none"), ("value", eventId)]) -> eventId }
      <table border="1">
        <tr>
          <td>Name:</td>
          <td>{input -> name}</td>
        </tr>
        <tr>
          <td>Dietary:</td>
          <td>{textarea() -> dietary}</td>
        </tr>
        <tr>
          <td colspan="2" style="text-align: center;">{submitButton("Register") -> submit}</td>
        </tr>
      </table>
    </#>
    yields
      (event = eventId,
       name=name,
       dietary=dietary)
}

fun processRegistration(data) server {
  page
    <#>
    </#>
}

fun registrationPage(_) server {
  fun prepareRegistrationPage(event, registrants)() {
     var name = stringToXml(event.name);
     var date = stringToXml(formatDate(event.date));
     var numAttendees = intToXml(length(registrants));

     page
       <html>
         <head>
           <meta charset="utf-8" />
           <title>RSVP for {name} ({date})</title>
         </head>
         <body>
           <h1>Event {name}, {date}</h1>
           <h2>Register</h2>
           { registerForm(event.id) => processRegistration }
           <h2>Attendees ({numAttendees})</h2>
           <ul>
           { for (registrant <- registrants) {
               <li>{stringToXml(registrant.name)}</li>
             }
           }
           </ul>
         </body>
       </html>
  }

  fun onFailurePage() {
     page
       <html>
         <head>
           <meta charset="utf-8" />
           <title>Error</title>
         </head>
         <body>
           <h1>Error: no such event</h1>
         </body>
       </html>
  }

  fun loadRegistrationPage(eventId) {
    var event = getEvent(eventId);
    var registrants = getRegistrants(event);
    prepareRegistrationPage(event, registrants)
  }

  handle({
    var config = makeConfig("evince");
    var id = lookup("id", environment());
    reader(config, fun() {loadRegistrationPage(id)})()
  }) {
    case Fail                -> onFailurePage()
    case Return(successPage) -> successPage()
  }
}

##
## Main
##
fun main() server {
  addRoute("/", registrationPage);
  servePages()
}

main()
