#
# The essence of React Fiber in Links with Effect Handlers
#
# Based on work by Nicole Meng (LFCS internship summer 2018)
#

# # Generate (locally) unique IDs
# fun genIdent(f) {
#   handle(f())(0 -> counter) {
#     case Gensym(resume) -> resume(counter, counter+1)
#   }
# }

# sig gensym : () {Gensym:a |_}-> a
# fun gensym() { do Gensym }

# Queue interface
# TODO: Implement a priority queue
typename Queue(a) = ([a], [a]);

sig enqueue : (a, Queue(a)) ~> Queue(a)
fun enqueue(x, (front, rear)) client {
   (front, x :: rear)
}

sig dequeue : (Queue(a)) ~> (Maybe(a), Queue(a))
fun dequeue(q) client {
  switch (q) {
    case ([], []) -> (Nothing, q)
    case ([], xs) -> dequeue((reverse(xs), []))
    case (x :: xs, ys) -> (Just(x), (xs, ys))
  }
}

var emptyQueue = ([], []) : Queue(a);

# Fiber interface
typename Fiber(e::Eff) = () {Fork:(Fiber({ |e})) -> (), Yield |e}~> ();

sig fork : (Fiber({ |e})) {Fork:(Fiber({ |e})) -> () |_}-> ()
fun fork(f) client { do Fork(f) }

sig yield : () {Yield |_}-> ()
fun yield() client { do Yield }

# Component interface
# TODO: Add priorities
typename Id = String;
typename StatefulFiber(s, e::Eff) = Fiber({Get:s, Put: (s) -> () |e});
typename Renderer(s,e::Eff)  = () {Fork:(Fiber({ |e})) -> (), Yield |e}~> Xml;
typename Mounter(s,e::Eff)   = () {Fork:(Fiber({ |e})) -> (), Yield |e}~> ();
typename Component(s,e::Eff) = (id:Id,                      # unique identifier
                              render    :Renderer(s,{ |e}), # HTML generating function
                              onMount   :Mounter(s,{ |e}),  # run once the component gets (re)mounted in the DOM tree
                              onTeardown:Mounter(s,{ |e})   # run once the component gets unmounted in the DOM tree
                             );

# # Component state
sig get : () {Get:s |_}-> s
fun get() { do Get }
sig put : (s) {Put:(s) -> () |_}-> ()
fun put(st) { do Put(st) }

#sig runComponent : (Component(s, {Get:s, Put:(s) -> () |e}), s) -> () {Fork:(Fiber({ Get: s,Put: (s) -> () |e})) -> (),Get{_},Put{_},Yield |e}~> ()
sig runComponent : (Component(s, {Get:s, Put:(s) -> () |e}), s) -> () {Fork:(Fiber({ Get: s,Put: (s) -> () |e})) -> (),Get{_},Put{_},Yield |e}~> ()
fun runComponent(component, st0)() client {
  handle({
    var virtNode  = component.render();
    var domNode   = getNodeById(component.id);
    var physNode  = getChildNodes(getValue(domNode)); # Get children as XML
    # TODO: Diff virtNode and physNode
    # TODO: only run onTeardown if physNode is being replaced
    component.onTeardown();
    domReplaceChildren(virtNode, domNode);
    component.onMount()
  })(st0 -> st) {
    case Return(x)       -> x
    case Get(resume)     -> resume(st, st)
    case Put(st, resume) -> resume((), st)
  }
}

sig makeComponent : (Id, Renderer(s, { |e}), Mounter(s, { |e}), Mounter(s, { |e})) -> Component(s, { |e})
fun makeComponent(id, render, onMount, onTeardown) {
  (id=id, render=render, onMount=onMount, onTeardown=onTeardown)
}

# Fiber scheduler interface
typename FiberResumption(e::Eff) = ((), SchedState({ |e})) {Fork-, Yield- |e}~> ();
typename SchedState(e::Eff) = (runQ:Queue(FiberResumption({ |e})), startTime:Int);
sig schedule : (Fiber({ |e})) {Fork-, Yield- |e}~> ()
fun schedule(fiber) client {
  sig makeSchedState : (Int, Queue(FiberResumption({ |d}))) -> SchedState({ |d})
  fun makeSchedState(startTime, runQ) {
    (startTime=startTime, runQ=runQ)
  }

  fun elapsed(startTime) {
    clientTime() - startTime
  }

  fun runNext(st) {
    switch (dequeue(st.runQ)) {
      case (Nothing,_) -> ()
      case (Just(resume), q) -> resume((), (st with runQ = q))
    }
  }

  sig promote : (Fiber({ |f})) -> FiberResumption({ |f})
  fun promote(fiber)((), st) {
    runFiber(fiber, st)
  }

  fun runFiber(fiber, initialState) {
     handle(fiber())(initialState -> st) {
       case Return(_) -> runNext(st)
       case Yield(resume) ->
         if (elapsed(st.startTime) < 100) {
           resume((), st)
         } else {
           var st = (st with runQ = enqueue(resume, st.runQ));
           runNext(st)
         }
       case Fork(fiber, resume) ->
         if (elapsed(st.startTime) < 100) {
           var st = (st with runQ = enqueue(promote(fiber), st.runQ));
           resume((), st)
         } else {
           var st = makeSchedState(clientTime(), st.runQ);
           runFiber(fiber, st)
         }
     }
  }
  runFiber(fiber, makeSchedState(clientTime(), emptyQueue));
}


sig forever : Fiber({ |e})
fun forever() client { yield(); forever() }

# # "Busy spinning" ain't much sleeping...
sig sleep : (Int) {Yield |_}~> ()
fun sleep(ms) client {
  fun loop(start, amount) {
    if (clientTime() - start >= amount) ()
    else { loop(start, amount); yield() }
  }
  loop(clientTime(), ms)
}

# Blinking "Hello World" component
typename BlinkState = (String, String);

sig swap : (BlinkState) -> BlinkState
fun swap((p,q)) client { (q, p) }

sig blinkComponent : (Id) ~e~> Component(BlinkState, { |%e})
fun blinkComponent(id) {
  fun render() {
    var (txt,_) = get();
    <h1>{stringToXml(txt)}</h1>
  }
  fun onMount() {
    sleep(50);
    var st = swap(get());
    fork(runComponent(blinkComponent(id), st))
   }
   makeComponent(id, render, onMount, fun() { () })
}


# Main page
fun mainPage(_) {
  var blink = blinkComponent("hello");
  var blinkState = ("Hello World!", "");
  ignore( spawnClient { schedule(runComponent(blink, blinkState)) } );
  page
    <#>
      <div id="{blink.id}"></div>
    </#>
}

fun main() {
  addRoute("/", mainPage);
  servePages()
}

main()
