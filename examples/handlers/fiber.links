#
# The essence of React Fiber in Links with Effect Handlers
#
# Based on work by Nicole Meng (LFCS internship summer 2018)
#

# # Generate (locally) unique IDs
# fun genIdent(f) {
#   handle(f())(0 -> counter) {
#     case Gensym(resume) -> resume(counter, counter+1)
#   }
# }

# sig gensym : () {Gensym:a |_}-> a
# fun gensym() { do Gensym }

# Queue interface
# TODO: Implement a priority queue
typename Queue(a) = ([a], [a]);

sig enqueue : (a, Queue(a)) ~> Queue(a)
fun enqueue(x, (front, rear)) client {
   (front, x :: rear)
}

sig dequeue : (Queue(a)) ~> (Maybe(a), Queue(a))
fun dequeue(q) client {
  switch (q) {
    case ([], []) -> (Nothing, q)
    case ([], xs) -> dequeue((reverse(xs), []))
    case (x :: xs, ys) -> (Just(x), (xs, ys))
  }
}

var emptyQueue = ([], []) : Queue(a);

# Fiber interface
typename Fiber(e::Eff) = () {Fork:(Fiber({ |e})) -> (), Yield |e}~> ();

sig fork : (Fiber({ |e})) {Fork:(Fiber({ |e})) -> () |_}-> ()
fun fork(f) client { do Fork(f) }

sig yield : () {Yield |_}-> ()
fun yield() client { do Yield }

# Component interface
# TODO: Add priorities
typename Id = String;
#typename StatefulFiber(s, e::Eff) = Fiber({Get:s, Put: (s) -> () |e});
typename Renderer(s,e::Eff)  = () {Fork:(Fiber({ |e})) -> (), Yield |e}~> Xml;
typename Mounter(s,e::Eff)   = () {Fork:(Fiber({ |e})) -> (), Yield |e}~> ();
typename Component(s,e::Eff) = (id:Id,                      # unique identifier
                              render    :Renderer(s,{ |e}), # HTML generating function
                              onMount   :Mounter(s,{ |e}),  # run once the component gets (re)mounted in the DOM tree
                              onTeardown:Mounter(s,{ |e})   # run once the component gets unmounted in the DOM tree
                             );

# Component state
sig get : () {Get:s |_}-> s
fun get() { do Get }
sig put : (s) {Put:(s) -> () |_}-> ()
fun put(st) { do Put(st) }

#sig runComponent : (Component(s, {Get:s, Put:(s) -> () |e}), s) -> () {Fork:(Fiber({ Get: s,Put: (s) -> () |e})) -> (),Get{_},Put{_},Yield |e}~> ()
sig runComponent : (Component(s, {Get:s, Put:(s) -> () |e}), s) -> () {Fork:(Fiber({ Get: s,Put: (s) -> () |e})) -> (),Get{_},Put{_},Yield |e}~> ()
fun runComponent(component, st0)() client {
  handle({
    var virtNode  = component.render();
    var domNode   = getNodeById(component.id);
    var physNode  = getChildNodes(getValue(domNode)); # Get children as XML
    # TODO: Diff virtNode and physNode
    # TODO: only run onTeardown if physNode is being replaced
    domReplaceChildren(virtNode, domNode);
    component.onMount()
  })(st0 -> st) {
    case Return(x)       -> x
    case Get(resume)     -> resume(st, st)
    case Put(st, resume) -> resume((), st)
  }
}

sig makeComponent : (Id, Renderer(s, { |e}), Mounter(s, { |e}), Mounter(s, { |e})) -> Component(s, { |e})
fun makeComponent(id, render, onMount, onTeardown) {
  (id=id, render=render, onMount=onMount, onTeardown=onTeardown)
}

# Fiber scheduler interface
typename FiberResumption(e::Eff) = ((), SchedState({ |e})) {Fork-, Yield- |e}~> ();
typename SchedState(e::Eff) = (runQ:Queue(FiberResumption({ |e})), startTime:Int);
sig schedule : (Fiber({ |e})) {Fork-, Yield- |e}~> ()
fun schedule(fiber) client {
  sig makeSchedState : (Int, Queue(FiberResumption({ |d}))) -> SchedState({ |d})
  fun makeSchedState(startTime, runQ) {
    (startTime=startTime, runQ=runQ)
  }

  fun elapsed(startTime) {
    clientTime() - startTime
  }

  fun runNext(st) {
    switch (dequeue(st.runQ)) {
      case (Nothing,_) -> ()
      case (Just(resume), q) -> resume((), (st with runQ = q))
    }
  }

  sig promote : (Fiber({ |f})) -> FiberResumption({ |f})
  fun promote(fiber)((), st) {
    runFiber(fiber, st)
  }

  fun runFiber(fiber, initialState) {
     handle(fiber())(initialState -> st) {
       case Return(_) -> runNext(st)
       case Yield(resume) ->
         if (elapsed(st.startTime) < 100) {
           resume((), st)
         } else {
           var st = (st with runQ = enqueue(resume, st.runQ));
           runNext(st)
         }
       case Fork(fiber, resume) ->
         if (elapsed(st.startTime) < 100) {
           var st = (st with runQ = enqueue(promote(fiber), st.runQ));
           resume((), st)
         } else {
           var st = makeSchedState(clientTime(), st.runQ);
           runFiber(fiber, st)
         }
     }
  }
  runFiber(fiber, makeSchedState(clientTime(), emptyQueue));
}


sig forever : Fiber({ |e})
fun forever() client { yield(); forever() }

# "Busy spinning" ain't much sleeping...
sig sleep : (Int) {Yield |_}~> ()
fun sleep(ms) client {
  fun loop(start, amount) {
    if (clientTime() - start >= amount) ()
    else { loop(start, amount); yield() }
  }
  loop(clientTime(), ms)
}

# Blinking "Hello World" component
typename BlinkState = (String, String);

sig swap : (BlinkState) -> BlinkState
fun swap((p,q)) client { (q, p) }

sig blinkComponent : (Id) ~e~> Component(BlinkState, { |%e})
fun blinkComponent(id) {
  fun render() {
    var (txt,_) = get();
    <h1>{stringToXml(txt)}</h1>
  }
  fun onMount() {
    sleep(50);
    var st = swap(get());
    fork(runComponent(blinkComponent(id), st))
   }
   makeComponent(id, render, onMount, fun() { () })
}

# Ball component
typename Direction = [|Up|Down|Left|Right|];
typename Ball = (x:Int,y:Int,velX:Int,velY:Int,size:Int);
typename Container = (width:Int,height:Int);
typename BallState = (Ball,Container);

fun makeBall(x, y, velX, velY, size) {
  (x=x,y=y,velX=velX,velY=velY,size=size)
}

sig moveBall : (Ball, Container) -> Ball
fun moveBall(ball, box) {
  var size = ball.size;
  var x = ball.x;
  var y = ball.y;

  var width  = box.width;
  var height = box.height;

  var velX = if ((x + size) >= height  || (x - size) <= 0) negate(ball.velX) else ball.velX;
  var velY = if ((y + size) >= width   || (y - size) <= 0) negate(ball.velY) else ball.velY;

  makeBall(x + velX, y + velY, velX, velY, size)
}

sig ballComponent : (Id) ~e~> Component(BallState, { |%e})
fun ballComponent(id) {
  fun render() {
    var (ball,_) = get();
    <#>
      <div class="ball" style="margin-top:{intToString(ball.x)}px;margin-left:{intToString(ball.y)}px;width:{intToString(ball.size)}px;height:{intToString(ball.size)}px;"></div>
    </#>
  }
  fun onMount() {
    sleep(3);
    var st0 = get();
    var ball = moveBall(st0.1, st0.2);
    var st = (ball, st0.2);
    fork(runComponent(ballComponent(id), st))
  }
  makeComponent(id, render, onMount, fun() { () })
}

# Main page
fun blinkingHelloPage() server {
  var blink = blinkComponent("hello");
  var blinkState = ("Hello World!", "");
  ignore( spawnClient { schedule(runComponent(blink, blinkState)) } );
  <#>
    <div id="{blink.id}"></div>
  </#>
}

fun bouncingBallPage() server {
  var ball = ballComponent("ball");
  var ballData = makeBall(50, 100, 5, -1, 40);
  var container = (width=400, height=400);
  ignore( spawnClient { schedule(runComponent(ball, (ballData, container))) } );
  <#>
    <div class="container" style="width:{intToString(container.width)}px;height:{intToString(container.height)}px;border:5px solid #000;">
      <ball id="{ball.id}" style="z-index:1;width:0px;height:0px;"></ball>
    </div>
  </#>
}

fun mainPage(_) server {
  var content = bouncingBallPage(); #blinkingHelloPage();
  page
    <#>
      <style type="text/css">
      body {{
        margin: 0;
      }}
      .container: {{
        margin: 0 auto;
        top: 0;
        border: 5px solid #000;
        display: inline;
      }}

      .ball {{
        border-radius: 200px 200px 200px 200px;
        background-color: purple;
        border: 3px solid red;
        z-index:2;
      }}
      </style>
      {content}
    </#>
}

fun main() server {
  addRoute("/", mainPage);
  servePages()
}

main()
