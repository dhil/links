## Doodle-like thingie
## Written by Daniel HillerstrÃ¶m (daniel.hillerstrom@ed.ac.uk), April 2019.

##
## Foreign functions.
##

##
## Hacky global knowledge.
##
module Hack {
  var nameNodeId = "input_0";
  var affiliationNodeId = "input_1";
  var dietaryNodeId = "input_2";
  var submitNodeId = "input_4";
}

##
## Utilities
##
module Maybe {
  sig fromJustDefault : (Maybe(a), a) -> a
  fun fromJustDefault(m, x) {
    switch (m) {
      case Nothing -> x
      case Just(y) -> y
    }
  }

  sig unsafeFromJust : (Maybe(a)) ~> a
  fun unsafeFromJust(m) {
    switch (m) {
      case Nothing -> error("fromJust of nothing")
      case Just(x) -> x
    }
  }

  sig map : ((a) -e-> b, Maybe(a)) -e-> Maybe(b)
  fun map(f, m) {
    switch (m) {
      case Nothing -> Nothing
      case Just(x) -> Just(f(x))
    }
  }

  sig isNothing : (Maybe(a)) -> Bool
  fun isNothing(m) {
    switch (m) {
      case Nothing -> true
      case _       -> false
    }
  }

  sig isJust : (Maybe(a)) -> Bool
  fun isJust(m) {not(isNothing(m))}

  sig just : (a) -> Maybe(a)
  fun just(x) {Just(x)}

  sig nothing : () -> Maybe(a)
  fun nothing() {Nothing}
}

module List {
  sig intersperse : (a, [a]) ~> [a]
  fun intersperse(y, xs) {
    switch (xs) {
      case []      -> []
      case [x]     -> [x]
      case x :: xs -> x :: y :: intersperse(y,xs)
    }
  }

  sig anyWitness : ((a) ~e~> Bool, [a]) ~e~> Maybe(a)
  fun anyWitness(f, xs) {
     switch (xs) {
       case [] -> Nothing
       case x :: xs ->
         if (f(x)) Just(x)
         else anyWitness(f, xs)
     }
  }
}

module Char {
  sig isAscii : (Char) -> Bool
  fun isAscii(c) {
    var c = ord(c);
    0 <= c && c < 128
  }

  sig isAsciiLetter : (Char) -> Bool
  fun isAsciiLetter(c) {
    var c = ord(c);
    (ord('a') <= c && c <= ord('z')) || (ord('A') <= c && c <= ord('Z'))
  }

  sig isAsciiBlank : (Char) ~> Bool
  fun isAsciiBlank(c) { isBlank(c) }

  sig isSpace : (Char) -> Bool
  fun isSpace(c) { ord(c) == ord(' ') }

  sig toCode : (Char) -> Int
  fun toCode(c) {ord(c)}

  sig fromCode : (Int) -> Char
  fun fromCode(x) {chr(x)}
}

module String {
  sig empty : String
  var empty = "";

  sig isEmpty : (String) -> Bool
  fun isEmpty(s) {s == empty}

  sig toCharList : (String) ~> [Char]
  fun toCharList(s) {explode(s)}

  sig fromCharList : ([Char]) ~> String
  fun fromCharList(cs) {implode(cs)}

  sig fromChar : (Char) ~> String
  fun fromChar(c) { fromCharList([c]) }

  sig split : (Char, String) ~> [String]
  fun split(delim, s) {
    fun strsplit_aux(cs, acc) {
      switch (cs) {
        case [] -> reverse(map(reverse, acc))
        case c :: cs ->
          if (c == delim) strsplit_aux(cs, [] :: acc)
          else switch (acc) {
               case ks :: kss -> strsplit_aux(cs, (c :: ks) :: kss)
          }
      }
    }
    map(fromCharList, strsplit_aux(toCharList(s), [[]]))
  }

  sig glue : (String, [String]) ~> String
  fun glue(glue, strings) {
    fold_right(fun(acc, string) { acc ^^ string }
               , String.empty, List.intersperse(glue, strings))
  }

  sig trim : (String) ~> String
  fun trim(s) {
    fun ltrim(cs) {
      switch (cs) {
        case c :: cs ->
          if (Char.isAsciiBlank(c)) ltrim(cs)
          else c::cs
        case _ -> cs
      }
    }
    fromCharList -<- reverse -<- ltrim -<- reverse -<- ltrim @ toCharList(s)
  }

  sig strip : ([Char], String) ~> String
  fun strip(symbols, s) {
    fun strstrip(cs,acc) {
      switch (cs) {
        case [] -> reverse(acc)
        case c :: cs ->
          if (c `elem` symbols) strstrip(cs, acc)
          else strstrip(cs, c :: acc)
      }
    }
    fromCharList(strstrip(toCharList(s), []))
  }

  sig stripbreaks : (String) ~> String
  fun stripbreaks(s) {
    strip(['\r','\n'], s)
  }

  sig stripempty : ([String]) ~> [String]
  fun stripempty(ss) {
    filter(fun(s) { not(isEmpty(s)) }, ss)
  }

  sig endsWith : (String, Char) ~> Bool
  fun endsWith(s, c) server {
    var len = strlen(s);
    if (len == 0) false
    else strsub(s, len - 1, 1) == fromChar(c)
  }
}

# sig isValidName : (String) ~> Bool
# fun isValidName(name) {
#   all(fun(c) { Char.isAsciiLetter(c) || Char.isAsciiBlank(c) }, String.toCharList(name))
# }

module Hex {
  sig fromInt : (Int) -> Char
  fun fromInt(d) {
    switch (mod(d, 16)) {
      case 10 -> 'a'
      case 11 -> 'b'
      case 12 -> 'c'
      case 13 -> 'd'
      case 14 -> 'e'
      case 15 -> 'f'
      case d  -> chr(48 + d)
    }
  }

  sig encode : (String) ~> String
  fun encode(s) {
    String.fromCharList(map(fromInt, map(Char.toCode, String.toCharList(s))))
  }

  sig randomDecimal : () ~> Char
  fun randomDecimal() {
    var d = floatToInt(floor(random() *. intToFloat(15)));
    fromInt(d)
  }
}

# Poor man's unique identifier generator
sig pseudoRandomByteString : (String, Int) ~> String
fun pseudoRandomByteString(seed, maxlen) server {
  fun gen(buf, len, ubound) {
    if (len < ubound) {
      var buf = buf ^^ String.fromChar(Hex.randomDecimal());
      gen(buf, len+1, ubound)
    } else if (len > ubound) {
      strsub(buf, 0, ubound)
    } else { buf }
  }
  var s = Hex.encode(seed);
  gen(s, strlen(s), maxlen)
}

##
## Reader interface
##
sig reader : (s, Comp({Ask:s |e}, a)) -> Comp({ |e}, a)
fun reader(item, m) {
  (fun() {
    handle(m()) {
      case Ask(resume) -> resume(item)
    }
  } : (Comp({ |e}, a)) <- (Comp({Ask- |e}, a))) # .. this is just.. well.. broken.
}

sig ask : () {Ask:a |_}-> a
fun ask() {do Ask}

##
## Exception interface
##
sig fail : () {Fail:Zero |_}~> a
fun fail() {switch(do Fail) { }}

sig maybe : (Comp({Fail:Zero |e}, a)) {Fail{_} |e}~> Maybe(a)
fun maybe(m) {
  handle(m()) {
    case Return(x) -> Just(x)
    case Fail      -> Nothing
  }
}

sig lookup : (a, [(a, b)]) {Fail:Zero |_}~> b
fun lookup(x, xs) {
  switch (xs) {
    case [] -> fail()
    case (y, z) :: xs ->
      if (x == y) z else lookup(x, xs)
  }
}

##
## Handling of input
##
typename InputValidationResult = [|TooManyCharacters|UnsupportedCharacter:Char|OK:Int|];
typename InputValidator = (String) {}~> InputValidationResult;
module InputValidator {
  sig maxlength : (Int) -> InputValidator
  fun maxlength(maxlen)(s) {
    var len = strlen(s);
    if (len < maxlen) OK(maxlen - len)
    else TooManyCharacters
  }

  sig onlyAsciiLetters : InputValidator
  fun onlyAsciiLetters(s) {
    fun predicate(c) {
       not(Char.isAsciiLetter(c)) && not(Char.isSpace(c))
    }
    var result = List.anyWitness(predicate, String.toCharList(s));
    switch (result) {
      case Nothing -> OK(0)
      case Just(c) -> UnsupportedCharacter(c)
    }
  }

  sig onlyAscii : InputValidator
  fun onlyAscii(s) {
    fun predicate(c) {
      not(Char.isAscii(c))
    }
    var result = List.anyWitness(predicate, String.toCharList(s));
    switch (result) {
      case Nothing -> OK(0)
      case Just(c) -> UnsupportedCharacter(c)
    }
  }

  sig apply : (InputValidator, String) {}~> InputValidationResult
  fun apply(validate, arg) { validate(arg) }

  sig compose : (InputValidator, InputValidator) -> InputValidator
  fun compose(fst, snd)(s) {
     fun max2(a, b) { if (a < b) b else a }

     switch (fst(s)) {
       case OK(i) ->
          switch (snd(s)) {
            case OK(j) -> OK(max2(i, j))
            case e     -> e
          }
       case e -> e
     }
  }

  sig ignore : InputValidator
  fun ignore(s) { OK(0) }

  sig name : InputValidator
  fun name(s) { apply(compose(maxlength(64), onlyAsciiLetters), s) }

  sig affiliation : InputValidator
  fun affiliation(s) {apply(name, s)}

  sig dietary : InputValidator
  fun dietary(s) { apply(compose(maxlength(128), onlyAscii), s) }
}

typename InputAction = (InputValidationResult) {}~> ();
module InputAction {
  sig highlight : (String) -> InputAction
  fun highlight(nodeId)(result) {
    var node = getNodeById(nodeId);
    switch (result) {
      case OK(_) -> domSetPropertyFromRef(node, "style", "border-color: none;")
      case _     -> domSetPropertyFromRef(node, "style", "border-width: 5px; border-color: red;")
    }
  }

  sig alert : ((InputValidationResult) {}~> Xml, String) -> InputAction
  fun alert(f, nodeId)(result) {
    var node = getNodeById(nodeId);
    var message = f(result);
    domReplaceChildren(message, node)
  }

  sig toggle : (String) -> InputAction
  fun toggle(nodeId)(result) {
    var node = getNodeById(nodeId);
    switch (result) {
      case OK(_) ->
        if (domHasAttribute(node, "disabled")) {
          domRemoveAttributeFromRef(node, "disabled")
        } else ()
      case _     ->
       if (not(domHasAttribute(node, "disabled"))) {
          domSetAttributeFromRef(node, "disabled", "disabled")
       } else ()
    }
  }

  sig compose : (InputAction, InputAction) -> InputAction
  fun compose(fst, snd)(result) {
     fst(result); snd(result)
  }

  sig ignore : InputAction
  fun ignore(_) { () }
}

typename InputListener = () {}~> ();
module InputListener {
  sig make : (InputValidator, InputAction, String) -> InputListener
  fun make(validate, inputHandler, nodeId)() {
     var inputNode = getNodeById(nodeId);
     var contents  = domGetPropertyFromRef(inputNode, "value");
     inputHandler(validate(contents))
  }

  sig message : (InputValidationResult) ~> Xml
  fun message(result) {
    var (msg, err) = switch (result) {
      case OK(n) -> (intToString(n) ^^ " characters remaining", false)
      case UnsupportedCharacter(c) -> ("Unsupported character '" ^^ String.fromChar(c) ^^ "'", true)
      case TooManyCharacters -> ("Too many characters", true)
    };
    var xmlMsg = stringToXml(msg);
    if (err) <span style="color:red;">{xmlMsg}</span>
    else xmlMsg
  }

  sig name : (String, String) -> InputListener
  fun name(nameNodeId, messageNodeId) {
     make( InputValidator.name
         , InputAction.compose(
             InputAction.compose( InputAction.toggle(Hack.submitNodeId)
                                 , InputAction.highlight(nameNodeId))
            , InputAction.alert(message, messageNodeId))
         , nameNodeId)
  }

  sig affiliation : (String, String) -> InputListener
  fun affiliation(affiliationNodeId, messageNodeId) {name(affiliationNodeId, messageNodeId)}

  sig dietary : (String, String) -> InputListener
  fun dietary(dietaryNodeId, messageNodeId) {
     make( InputValidator.dietary
         , InputAction.compose(
             InputAction.compose( InputAction.toggle(Hack.submitNodeId)
                                 , InputAction.highlight(dietaryNodeId))
            , InputAction.alert(message, messageNodeId))
         , dietaryNodeId)
  }
}

typename SanitationResult = [|OK:String|BadInput|];
typename Sanitiser = (String) {}~> SanitationResult;
module Sanitise {
  sig apply : (Sanitiser, String) {}~> SanitationResult
  fun apply(sanitise, arg) { sanitise(arg) }

  sig withCheck : (InputValidator, Sanitiser) -> (String) {}~> SanitationResult
  fun withCheck(validate, sanitise)(s) {
    switch (InputValidator.apply(validate, s)) {
      case OK(_) -> apply(sanitise, s)
      case _     -> BadInput
    }
  }

  sig compose : (Sanitiser, Sanitiser) -> (String) {}~> SanitationResult
  fun compose(fst, snd)(s) {
     var result = apply(fst, s);
     switch (apply(fst, s)) {
       case BadInput -> BadInput
       case OK(s)    -> apply(snd, s)
     }
  }

  sig trim : Sanitiser
  fun trim(s) { OK(String.trim(s)) }

  sig escapeAscii : Sanitiser
  fun escapeAscii(s) { OK(strescape(s)) }

  sig name : Sanitiser
  fun name(s) { apply(withCheck(InputValidator.name, trim), s) }

  sig affiliation : Sanitiser
  fun affiliation(s) {apply(name, s)}

  sig dietary : Sanitiser
  fun dietary(s) {
    apply(withCheck(InputValidator.dietary, compose(trim, escapeAscii)), s)
  }
}

##
## Server API
##
typename ProtoEvent(a) = (id:String,name:String,done:a,date:String,created:String);
typename RawEvent = ProtoEvent(Int);
typename Event = ProtoEvent(Bool);
typename NewEvent = (name:String);

typename ProtoRegistrant(e::Row) = (id:Int,event:String,dietary:String,affiliation:String,timestamp:String,name:String,stamp:String);
typename RawRegistrant = (event:String,dietary:String,affiliation:String,name:String,stamp:String);
typename Registrant = (id:Int,dietary:String,affiliation:String,name:String,stamp:String);
typename NewRegistrant = (name:String,affiliation:String,dietary:String,stamp:String);

typename Config = (events: () {}~> TableHandle(RawEvent, RawEvent, RawEvent),
                   writeRegistrants: () {}~> TableHandle(RawRegistrant, RawRegistrant, RawRegistrant),
                   readRegistrants : () {}~> TableHandle(ProtoRegistrant({ }), ProtoRegistrant({ }), ProtoRegistrant({ }))
                   );

module Config {
  sig make : (String) ~> Config
  fun make(dbname) server {
    (events = fun() {
       table "events" with (id:String,name:String,done:Int,date:String,created:String)
       from database dbname
     },
     writeRegistrants = fun() {
       table "registrants" with (event:String,name:String,affiliation:String,dietary:String,stamp:String)
       from database dbname
     },
     readRegistrants = fun() {
       table "registrants" with (id:Int,event:String,name:String,affiliation:String,dietary:String,timestamp:String,stamp:String)
       from database dbname
     })
  }
}

module Database {
  sig expectSingle : ((a) {Fail:Zero|e}~> b, [a]) {Fail:Zero |e}~> b
  fun expectSingle(f, xs) {
    switch (xs) {
      case [x] -> f(x)
      case _   -> fail()
    }
  }
}

module Event {
  sig get : (String) {Ask:Config, Fail:Zero |_}~> Event
  fun get(id) server {
    var config = ask();
    var events = gen0(config.events)();
    var results = query {
       for (event <-- events)
       where (event.id == id)
       [event]
    };

    switch (results) {
      case [event] ->
        (id=event.id, name=event.name, done = (event.done <> 0), date=event.date, created = event.created)
      case _ -> fail()
    }
  }
}

module Registrant {
  fun interpRaw(r) {
    (name=r.name,affiliation=r.affiliation,dietary=strunescape(r.dietary),id=r.id,stamp=r.stamp)
  }

  sig add : (String, NewRegistrant) {Ask:Config, Fail:Zero |_}~> Registrant
  fun add(eventId, x) server {
    var config = ask();
    var registrations = gen0(config.writeRegistrants)();
    insert registrations values [(event=eventId,stamp=x.stamp, affiliation=x.affiliation, name=x.name, dietary=x.dietary)];

    var registrations = gen0(config.readRegistrants)();
    var result = query {
      for (registrant <-- registrations)
      where (registrant.stamp == x.stamp && registrant.event == eventId)
      [registrant]
    };

    Database.expectSingle(interpRaw, result)
  }

  sig remove : (String, Registrant) {Ask:Config, Fail:Zero |_}~> ()
  fun remove(eventId, registrant) server {
    var config = ask();
    var registrants = gen0(config.readRegistrants)();
    delete (dbregistrant <-- registrants)
    where (dbregistrant.id == registrant.id && dbregistrant.event == eventId && dbregistrant.stamp == registrant.stamp);
  }

  sig modify : (String, Registrant) {Ask:Config |_}~> ()
  fun modify(eventId, registrant) server {
    var config = ask();
    var registrants = gen0(config.readRegistrants)();
    update (dbregistrant <-- registrants)
    where (dbregistrant.id == registrant.id && dbregistrant.event == eventId)
    set (name=registrant.name,affiliation=registrant.affiliation,dietary=registrant.dietary)
  }

  sig get : (String, Int) {Ask:Config, Fail:Zero |_}~> Registrant
  fun get(eventId, id) server {
    var config = ask();
    var registrants = gen0(config.readRegistrants)();
    var results = query {
      for (registrant <-- registrants)
      where (registrant.id == id && registrant.event == eventId)
      [registrant]
    };

    Database.expectSingle(interpRaw, results)
  }

  sig getUsing : (String, Int, String) {Ask:Config, Fail:Zero |_}~> Registrant
  fun getUsing(eventId, id, stamp) server {
    var config = ask();
    var registrants = gen0(config.readRegistrants)();
    var results = query {
      for (registrant <-- registrants)
      where (registrant.stamp == stamp && registrant.id == id && registrant.event == eventId)
      [registrant]
    };

    Database.expectSingle(interpRaw, results)
  }

  sig getAll : (Event) {Ask:Config |_}~> [Registrant]
  fun getAll(ev) server {
    var config = ask();
    var registrants = gen0(config.readRegistrants)();
    var results = query {
       for (registrant <-- registrants)
       where (registrant.event == ev.id)
       orderby (registrant.name)
       [registrant]
    };
    map(interpRaw, reverse(results))
  }
}

##
## Front end utilities
##
sig formatDate : (String) ~> String
fun formatDate(date) {
  fun month(m) {
    switch (stringToInt(m)) {
      case 1 -> "January"
      case 2 -> "February"
      case 3 -> "March"
      case 4 -> "April"
      case 5 -> "May"
      case 6 -> "June"
      case 7 -> "July"
      case 8 -> "August"
      case 9 -> "September"
      case 10 -> "October"
      case 11 -> "November"
      case 12 -> "December"
      case _  -> error("bad input")
    }
  }
  var components = String.split('-', date);
  switch (components) {
    case [y, m, d] ->
      month(m) ^^ " " ^^ d ^^ ", " ^^ y
    case _ -> error("bad input")
  }
}


##
## Configuration
##
sig defaultConfig : () ~> Config
fun defaultConfig() server { Config.make("evince") }

##
## Pages
##
sig textarea : (String, () ~> ()) ~> Formlet (String)
fun textarea(defaultValue, keyUpListener) {
  fun mkTextarea(name, defaultValue, keyUpListener) {
    <textarea id="{name}" name="{name}" l:onkeyup="{keyUpListener()}">{stringToXml(defaultValue)}</textarea>
  }

  mkInput(fun(name) { mkTextarea(name, defaultValue, keyUpListener) }
         ,fun(name, value) { mkTextarea(name, value, keyUpListener) })
}

fun inputField(defaultValue, keyUpListener) {
  fun makeInputField(name, defaultValue, keyUpListener) {
    <input id="{name}" name="{name}" l:onkeyup="{keyUpListener()}" value="{defaultValue}" />
  }
  mkInput(fun(name) { makeInputField(name, defaultValue, keyUpListener) }
         ,fun(name, value) { makeInputField(name, value, keyUpListener) })
}

fun makeSubmitButton(value) {
  mkInput(fun(name) { <input type="submit" value="{value}" name="{name}" id="{name}" /> },
          fun(name, _) { <input type="submit" value="{value}" name="{name}" id="{name}" /> })
}

sig closedForm : () ~> Formlet(%)
fun closedForm() server {
  formlet
    <#>
      {stringToXml("Registration is closed.")}
    </#>
    yields
      (event = "",
       name = "",
       affiliation = "",
       dietary = "",
       deleteMe = false,
       id = Nothing,
       stamp = Nothing)
}

sig registerForm : (Event, Maybe(Registrant)) ~> Formlet(%)
fun registerForm(event, registrant) server {
  fun remainingCharacters(start, max) { stringToXml(intToString(max - strlen(start))) }
  var name = Maybe.fromJustDefault(Maybe.map(fun(r) { r.name }, registrant), String.empty);
  var affiliation = Maybe.fromJustDefault(Maybe.map(fun(r) { r.affiliation }, registrant), String.empty);
  var dietary = Maybe.fromJustDefault(Maybe.map(fun(r) { r.dietary }, registrant), String.empty);
  var uid = Maybe.map(fun(r) { r.id }, registrant);
  var stamp = Maybe.map(fun(r) { r.stamp }, registrant);
  var (submitButtonLabel, deleteStyle) =
     if (Maybe.isNothing(uid)) ("Register", "display:none")
     else ("Update", "");
  formlet
    <#>
      <table border="1">
        <tr>
          <td>Name:</td>
          <td>
            <table border="0">
              <tr>
                <td>{inputField(name, InputListener.name(Hack.nameNodeId, "name-message")) -> name}</td>
              </tr>
              <tr>
                <td><span id="name-message">{remainingCharacters(name, 64)} characters remaining</span></td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td>Affiliation:</td>
          <td>
            <table border="0">
              <tr>
                <td>{inputField(affiliation, InputListener.affiliation(Hack.affiliationNodeId, "affiliation-message")) -> affiliation}</td>
              </tr>
              <tr>
                <td><span id="affiliation-message">{remainingCharacters(affiliation, 64)} characters remaining</span></td>
              </tr>
            </table>
           </td>
        </tr>
        <tr>
          <td>Dietary:</td>
          <td>
            <table border="0">
              <tr>
                <td>{textarea(dietary, InputListener.dietary(Hack.dietaryNodeId, "dietary-message")) -> dietary}</td>
              </tr>
              <tr>
                <td><span id="dietary-message">{remainingCharacters(dietary, 128)} characters remaining</span></td>
              </tr>
            </table>
          </td>
        </tr>
        <tr style="{deleteStyle}">
          <td>Delete</td>
          <td>{checkbox -> deleteMe}</td>
        </tr>
        <tr>
          <td colspan="2" style="text-align: center;">
            {makeSubmitButton(submitButtonLabel) -> submit}
          </td>
        </tr>
      </table>
    </#>
    yields
      (event = event.id,
       name = name,
       affiliation = affiliation,
       dietary = dietary,
       deleteMe = deleteMe,
       id = uid,
       stamp = stamp)
}

module RegistrationPage {
  sig failurePage : (String) ~> Page
  fun failurePage(errorMessage) {
    page
      <html>
        <head>
          <meta charset="utf-8" />
          <title>Error</title>
        </head>
        <body>
          <h1>Error: {stringToXml(errorMessage)}</h1>
        </body>
      </html>
  }

mutual {
  sig mainPage : (Event, [Registrant], Maybe(Registrant)) ~> Page
  fun mainPage(event, registrants, registrant) {
    var name = stringToXml(event.name);
    var date = stringToXml(formatDate(event.date));
    var numAttendees = intToXml(length(registrants));

    page
      <html>
        <head>
          <meta charset="utf-8" />
          <title>RSVP for {name} ({date})</title>
          <link rel="stylesheet" type="text/css" href="static/css/style.css" />
        </head>
        <body>
          <h1>Event {name}, {date}</h1>
          <h2>Register</h2>
          { (if (event.done) closedForm() else registerForm(event, registrant)) => processRegistration }
          <h2>Attendees ({numAttendees})</h2>
          <ul>
          { for (registrant <- registrants) {
              var nameAffiliation =
                registrant.name ^^
                  (if (not(String.isEmpty(registrant.affiliation))) ", " ^^ registrant.affiliation else String.empty);
              <li>
                {stringToXml(nameAffiliation)}
              </li>
            }
          }
          </ul>
          <hr />
          <h2>About this application</h2>
          <p>This application is powered by <a href="http://links-lang.org">modern programming technology based on cutting-edge research</a> for implementing modular, expressive, efficient, robust, and safe multi tier web applications.</p>
          <p>In fact, this application is so robust and safe, that users may only input characters from the US-ASCII character set.</p>
          <h3>References</h3>
          <ul>
            <li>S. Fowler, S. Lindley, J. G. Morris, and S. Decova,
                <a href="http://www.simonjf.com/writing/zap.pdf">Exceptional Asynchronous Session Types: Session Types without Tiers</a>, POPL 2019</li>
            <li>D. Hillerstrom and S. Lindley, <a href="http://homepages.inf.ed.ac.uk/slindley/papers/handlers-cps.pdf">Continuation Passing Style for Effect Handlers</a>, FSCD 2017</li>
            <li>S. Lindley and J. G. Morris, <a href="http://homepages.inf.ed.ac.uk/slindley/papers/fst.pdf">Lightweight functional session types</a>, in <i>Behavioural Types: from Theory to Tools</i> 2017</li>
            <li>D. Hillerstrom and S. Lindley, <a href="http://homepages.inf.ed.ac.uk/s1467124/papers/liberating_effects-tyde2016.pdf">Liberating Effects with Rows and Handlers</a>, TyDe@ICFP 2016</li>
            <li>S. Lindley and J. Cheney, <a href="http://homepages.inf.ed.ac.uk/slindley/papers/corelinks.pdf">Row-based effect types for database integration</a>, TLDI 2012</li>
            <li>E. Cooper, S. Lindley, P. Wadler, and J. Yallop, <a href="http://links-lang.org/formlets/">The essence of form abstraction</a>, APLAS 2008</li>
            <li>E. Cooper, S. Lindley, P. Wadler, and J. Yallop, <a href="http://links-lang.org/papers/links-fmco06.pdf">Links: web programming without tiers</a>, FMCO 2006</li>
          </ul>
        </body>
      </html>
  }

  fun processRegistration(data) server {
    fun sanitise(data) {
      switch ((gen1(Sanitise.name)(data.name)
             , gen1(Sanitise.affiliation)(data.affiliation)
             , gen1(Sanitise.dietary)(data.dietary))) {
       case (OK(name), OK(affiliation), OK(dietary)) ->
         (data with name = name, affiliation = affiliation, dietary = dietary)
       case _ -> fail()
      }
    }

    fun register(event, data) {
      var stamp = pseudoRandomByteString(data.name ^^ intToString(serverTime()), 128);
      var (registrant : NewRegistrant) = (name=data.name,stamp=stamp,affiliation=data.affiliation,dietary=data.dietary);
      var registrant = Registrant.add(data.event, registrant);
      # Set cookie parameters.
      setCookie("rsvp-" ^^ event.id, intToString(registrant.id) ^^ ":" ^^ stamp);
      Just(registrant)
    }

    fun modify(event, data) {
      var registrant = Registrant.getUsing(event.id, data.id, data.stamp);
      var registrant = (registrant with name = data.name, affiliation = data.affiliation, dietary = strunescape(data.dietary));
      Registrant.modify(event.id, registrant);
      Just(registrant)
    }

    fun remove(event, data) {
      # Unset cookie.
      setCookie("rsvp-" ^^ event.id, "");
      Registrant.remove(event.id, Registrant.getUsing(event.id, data.id, data.stamp));
      Nothing
    }

    fun processData() {
      var event =
        if (String.isEmpty(data.event)) fail()
        else Event.get(data.event);
      var registrant = switch ((data.id, data.stamp)) {
        case (Nothing, Nothing)  -> register(event, sanitise(data))
        case (Just(id), Just(stamp)) ->
          var data = sanitise((data with id = id, stamp = stamp));
          if (data.deleteMe) remove(event, data)
          else modify(event, data)
        case _ -> fail()
      };

      switch (registrant) {
        case Just(registrant) -> loadUsing(event, registrant)("")
        case Nothing ->
          page
           <#>
            <h1>Thank you</h1>
           </#>
      }
    }

    handle(reader(defaultConfig(), processData)()) {
      case Fail      -> failurePage("fatal internal error")
      case Return(successPage) -> successPage
    }
  }

  sig loadUsingEnvironment : (String) {Ask:Config,Fail{_} |_}~> Page
  fun loadUsingEnvironment(resource) {
    fun tryLoadRegistrant(event)() {
      var data = getCookie("rsvp-" ^^ event.id);
      if (not(String.isEmpty(data))) {
        var (id, stamp) = switch (String.split(':', data)) {
          case [id, stamp] -> (stringToInt(id), stamp)
          case _           -> fail()
        };
        Registrant.getUsing(event.id, id, stamp)
      } else fail()
    }

    handle(Event.get(lookup("id", environment()))) {
      case Fail -> failurePage("no such event")
      case Return(event) ->
        handle(Registrant.getAll(event)) {
          case Fail -> failurePage("fatal internal error")
          case Return(registrants) ->
            var registrant = maybe(tryLoadRegistrant(event));
            mainPage(event, registrants, registrant)
        }
    }
  }

  sig loadUsing : (Event, Registrant) -> (String) {Ask:Config,Fail{_} |_}~>Page
  fun loadUsing(event, registrant)(resource) {
    handle(Registrant.getAll(event)) {
      case Fail -> failurePage("fatal internal error")
      case Return(registrants) -> mainPage(event, registrants, Maybe.just(registrant))
    }
  }
}
}

##
## Main
##
fun preparePage(genPage)(resource) {
  reader(defaultConfig(), fun() {genPage(resource)})()
}


fun main() server {
  addRoute("/", preparePage(RegistrationPage.loadUsingEnvironment));

  addStaticRoute("/static/css", "app/static/css", [("css", "text/css")]);

  servePages()
}

main()
