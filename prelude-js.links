# Required

# Standard type aliases
typename Maybe(a) = [|Just:a|Nothing|];
typename Comp(e::Eff, a) = () ~e~> a;

# Standard functions
fun id(x) {x}

sig ignore : (a) -> ()
fun ignore(_) { () }

sig assert : ((a,a) ~e~> Bool, (a) ~e~> String, a, a) ~e~> ()
fun assert(eq, toString, expected, actual) {
  ignore(
    not(eq(expected, actual)) && error("Assertion error: " ^^ toString(expected) ^^ " != " ^^ toString(actual))
  )
}

# Don't use a for comprehension to define concatMap, as
# for comprehensions are desugared into concatMap!
sig concatMap : ((a) ~e~> [b], [a]) ~e~> [b]
fun concatMap(f, xs) {
  switch (xs) {
    case [] -> []
    case x::xs -> f(x) ++ concatMap(f, xs)
  }
}

sig fold_left : ((a, b) ~e~> a, a, [b]) ~e~> a
fun fold_left(f, acc, xs) {
  switch (xs) {
    case [] -> acc
    case x::xs -> fold_left(f, f(acc, x), xs)
  }
}

sig reverse : ([a]) ~> [a]
fun reverse(xs) {
   fun rev_aux(xs, acc) {
      switch (xs) {
         case [] -> acc
         case x :: xs -> rev_aux(xs, x :: acc)
      }
   }
   rev_aux(xs, [])
}

sig map : ((a) ~e~> b, [a]) ~e~> [b]
fun map(f, l) {
  fun map_aux(f, xs, acc) {
    switch (xs) {
      case []    -> acc
      case x::xs -> map_aux(f, xs, f(x) :: acc)
    }
  }
  reverse(map_aux(f, l, []))
}

sig filter : ((a) ~e~> Bool, [a]) ~e~> [a]
fun filter(p, l) {
  concatMap (fun (x) {if(p(x)) [x] else []}, l)
}

sig sortBy : ((a) ~b~> c, [a]) ~b~> [a]
fun sortBy (f, l) {
  switch (l) {
    case [] -> []
    case x::xs -> {
      var lt = filter (fun (y) {f(y) < f(x)}, xs);
      var ge = filter (fun (y) {f(y) >= f(x)}, xs);
      sortBy(f, lt) ++ [x] ++ sortBy(f, ge)
    }
  }
}

sig sortByBase : ((a) ~b~> (| _::Base), [a]) ~b~> [a]
fun sortByBase(f, l) {sortBy(f, l)}

sig iteri : ((Int, a) ~e~> (), Array(a)) ~e~> ()
fun iteri(f, a) {
  fun iteri_aux(f, i, a) {
     if (i < arrayLength(a)) {
       f(i, arrayGet(a, i)); iteri_aux(f, i+1, a)
     } else { () }
  }
  iteri_aux(f, 0, a)
}

sig iterate : ((Int) ~e~> (), Int, Int) ~e~> ()
fun iterate(f, i, n) {
  if (i < n) { f(i); iterate(f, i+1, n) }
  else ()
}

fun foldArray(f,z,a) {
  var acc = ref(z);
  iterate(fun(i) {
     acc := f(deref(acc), arrayGet(a, i))
  }, 0, arrayLength(a));
  deref(acc)
}

