# Stateful counting
# Microbenchmark adapted from Kammar et al. (2013).

sig get : () {Get:s|_}-> s
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}-> ()
fun put(st) {do Put(st)}

sig count : (Comp({Get:Int,Put:(Int) {}-> () |_}, Int))
fun count() {
  var n = get();
  if (n == 0) 0
  else { put(n-1); count() }
}

sig evalState : (Comp({Get:s ,Put:(s) {}-> () |e}, a), s) -> Comp({Get{_},Put{_} |e}, a)
fun evalState(m, st)() {
    evalState0(m, st)
}

fun evalState0(m, st) {
  shallowhandle(m()) {
    case Return(x)     -> x
    case Get(resume)   -> evalState0(fun() { resume(st) }, st)
    case Put(p,resume) -> evalState0(fun() { resume(()) }, p)
  }
}

benchmark("Shallow counting (functional state)", (==), 0, evalState(count,1000000))
