# Deep encoding of pipes
# Adapted from Kammar et al. (2013)

typename Comp(e::Eff,a) = () ~e~> a;

typename Producer(e::Eff, a) = (()) ~e~> (Consumer(e, a)) ~e~> ();
typename Consumer(e::Eff, a) = (a)  ~e~> (Producer(e, a)) ~e~> ();

typename Pump(e::Eff,o)     = Comp({Yield:(o) {}-> () |e}, ());
typename Sink(e::Eff,i)     = Comp({Await:i           |e}, ());
typename Pipe(e::Eff,i,o)   = Comp({ |e}, ());

# Yield an element
sig yield : (a) {Yield:(a) {}-> ()|_}-> ()
fun yield(s) { do Yield(s) }

# Consume an element
sig await : () {Await:a |_}-> a
fun await() { do Await }

# Handles yield
sig up0 : (Comp( {Yield:(s) {}-> () |e}, ()))
                {Yield{yp}         |e}~>
	  Comp( {Yield{yp}         |e}, (Consumer({Yield{yp} |e}, s)) {Yield{yp} |e}~> ())
fun up0(m)() {
  handle(m()) {
    case Return(x)   -> fun(_) { x }
    case Yield(s, k) ->
      fun(cons : Consumer({Yield{yp} |e}, s)) {
          cons(s)(k)
          #cons(s)(fun() { k(()) })
      }
  }
}

# Swap argument order
sig up : (Consumer({Yield{yp} |e}, s)) -> (Pump({ |e}, s)) {Yield{yp} |e}~> ()
var up = fun(cons)(m) { up0(m)()(cons) };

# Handles await
sig down0 : ( Comp( {Await:s |e}, ()) )
                   {Await{ap} |e}~>
             Comp( {Await{ap} |e}, (Producer({Await{ap} |e}, s)) {Await{ap} |e}~> ())
fun down0(m)() {
  handle(m()) {
    case Return(x) -> fun(_) { x }
    case Await(k)  ->
     fun(prod : Producer({Await{ap} |e}, s)) {
         prod(())(k)
         #prod()(fun(s) { k(s) })
     }
  }
}

sig down : (Producer({Await{ap} |e}, s)) -> (Sink({ |e}, s)) {Await{ap} |e}~> ()
var down = fun(prod)(m) { down0(m)()(prod) };

# Some combinators
# sig <+< : ( Comp({Await:s  , Yield{yp}          |e}, ())      # in: down
#           , Comp({Await{ap}, Yield:(s) {}-> ()  |e}, ()) ) -> # in: up
# 	      Comp({Await{ap}, Yield{yp}          |e}, ())      # out: pipe
sig <+< : (Sink({ Yield{yp} |e}, s), Pump({ Await{ap} |e}, s)) -> Pipe({ Await{ap}, Yield{yp} |e}, s, s)
op d <+< u {
  fun() { down(fun(())(cons) { up(cons)(u) })(d) }
}

# sig >+> : ( Comp({Await{ap}, Yield:(s) {}-> ()  |e}, ())      # in: up
#           , Comp({Await:s  , Yield{yp}          |e}, ()) ) -> # in: down
# 	      Comp({Await{ap}, Yield{yp}          |e}, ())      # out: pipe
sig >+> : ( Pump({ Await{ap} |e}, s), Sink({ Yield{yp} |e}, s)) -> Pipe({ Await{ap}, Yield{yp} |e}, s, s)
op u >+> d {
  d <+< u
}

# Some producers and consumers
# Produces an infinite stream of integers starting from [n] *)
#sig produceFrom : (Int) -> Comp({Yield:(Int) {}-> () |_}, ())
sig produceFrom : (Int) -> Pump({ |_}, Int)
fun produceFrom(n)() {
  fun produceFrom0(n) {
    yield(n);
    produceFrom0(n+1)
  }
  produceFrom0(n)
}

# Accumulates elements from an integer stream until the sum is greater than or equal to [n]
#sig sumTo : (Int) -> Comp({Await:Int, Yield:(Int) {}-> () |_}, ())
sig sumTo : (Int) -> Pipe({ Await:Int, Yield:(Int) {}-> () |_}, Int, Int)
fun sumTo(n)() {
  fun sumTo_aux(acc, lim) {
    if (acc >= lim) {
      yield(acc)
    } else {
      var x = await();
      sumTo_aux(acc+x, lim)
    }
  }
  sumTo_aux(0, n)
}

# Skips [n] elements from an arbitrary stream
#sig skip : (Int) -> Comp({Await:s, Yield:(s) {}-> () |_}, ())
sig skip : (Int) -> Pipe({ Await:s, Yield:(s) {}-> () |_}, s, s)
fun skip(n)() {
  fun skip0(n) {
    if (n <= 0) {
      var x = await();
      var _ = yield(x);
      skip0(0)
    } else {
      var _ = await();
      skip0(n-1)
    }
  }
  skip0(n)
}

# Turns a stream of as into a stream of bs
#sig converter : ((a) {Await:a, Yield:(b) {}-> () |e}~> b) -> Comp({Await:a,Yield:(b) {}-> () |e}, ())
sig converter : ((a) {Await:a, Yield:(b) {}-> () |e}~> b) -> Pipe({ Await:a, Yield:(b) {}-> () |e}, a, b)
fun converter(conv)() {
    var b = conv(await());
    yield(b);
    converter(conv)()
}

# Prints a stream of as
#sig printer : ((a) {Await:a |e}~> String) -> Comp({Await:a |e}, ())
sig printer : ((a) {Await:a |e}~> String) -> Sink({ |e}, a)
fun printer(toString)() {
    var n = await();
    print(toString(n));
    printer(toString)()
}

fun forever(f) {
  ignore(f());
  forever(f)
}

fun expoPipe(n)() {
  fun expoPipe0(n) {
    if (n == 0) {
       forever(fun() {
         var x = await();
         yield(x+1)
       })
    } else {
        (fun() { expoPipe0(n-1) } <+< fun() { expoPipe0(n-1) })()
    }
  }
  expoPipe0(n)
}

fun take1(n)() {
  fun take0(n) {
    if (n <= 0) ()
    else {
      var x = await();
      yield(x);
      take0(n-1)
   }
 }
 take0(n)
}

fun blackhole() { forever(await) }

fun nested(start, depth, end) {
  var pipeline = blackhole <+< take1(end) <+< expoPipe(depth) <+< produceFrom(start);
  pipeline()
}

# typename Producer(e::Eff, a) = () ~e~> (Consumer(e, a)) ~e~> ();
# typename Consumer(e::Eff, a) = (a)  ~e~> (Producer(e, a)) ~e~> ();

# fun dpipe(cons) {
#   handle(cons()) {
#     case Return(x) -> fun(_) { x }
#     case Await(resume) ->
#       fun(prod : Producer({Await{%} |%e}, %)) { prod()(resume) }
#   }
# }

# fun dcopipe(prod) {
#   handle(prod()) {
#     case Return(x) -> fun(_) { x }
#     case Yield(s, resume) ->
#       fun(cons : Consumer({Yield{%} |%e}, %)) { cons(s)(fun() { resume(()) }) }
#   }
# }

# #dpipe(sumUp(10000000))(fun() { dcopipe(produce) })

benchmark("Deep pipes", fun((), ()) { true }, (), fun() { nested(0, 10, 1000) })

# # Examples
# fun example() {
#   ( printer(id)               # sink
#  <+<
#     converter(floatToString)  # yields STRING
#  <+<
#     converter(intToFloat)     # yields FLOAT
#  <+<
#     sumTo(100)                # yields INT
#  <+<
#     produceFrom(0)            # yields INT
#   )()
# }

# fun example2() {
#   ( produceFrom(0)            # yields INT
#  >+>
#     skip(99)                  # yields INT
#  >+>
#     sumTo(100)                # yields INT
#  >+>
#     converter(intToFloat)     # yields FLOAT
#  >+>
#     converter(floatToString)  # yields STRING
#  >+>
#     printer(id)               # sink
#  ) ()
# }

# # End
# #sig end : Sink({Await:a |e}, a)
# fun end() {await()}

# fun forward() {
#   var x = do Await;
#   print("Received " ^^ intToString(x));
#   print("Yielding " ^^ intToString(x));
#   do Yield(x)
# }

# fun unitTest(n) {
#   handle(
#    ( produceFrom(n)            # yields INT
#   >+>
#      skip(99)                  # yields INT
#   >+>
#      sumTo(100)                # yields INT
#   >+>
#      converter(intToFloat)     # yields FLOAT
#   >+>
#      converter(floatToString)  # yields STRING
#   ) ()) {
#     case Return(_)  -> error("Unexpected return.")
#     case Await(_,_) -> error("Unexpected await.")
#     case Yield(x,_) -> x
#   }
# }

# #alien javascript "benchmarks/handlers/js/benchmark_suite.js" benchmark : (String, (%a,%a) ~%e~> Bool, %a, () ~%e~> %a) ~%e~> ();

# #benchmark("Deep pipes", (==), "199", fun() { unitTest(0) })

# print(unitTest(0))

