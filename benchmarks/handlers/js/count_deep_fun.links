# Stateful counting
# Microbenchmark adapted from Kammar et al. (2013).

typename Comp(e::Eff,a) = () ~e~> a;

sig get : () {Get:s|_}-> s
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}-> ()
fun put(st) {do Put(st)}

sig count : (Comp({Get:Int,Put:(Int) {}-> () |_}, Int))
fun count() {
  var n = get();
  if (n == 0) 0
  else { put(n-1); count() }
}

fun run() {
  var start =
     handle(count()) {
       case Return(x)     -> fun(_) { x }
       case Get(resume)   -> fun(st) { resume(st)(st) }
       case Put(p,resume) -> fun(_) { resume(())(p) }
     };
  #start(1000000)
  start(10000)
}

benchmark("Deep counting (functional state)", (==), 0, run)
