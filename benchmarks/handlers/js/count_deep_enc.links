# Stateful counting
# Microbenchmark adapted from Kammar et al. (2013).

typename Comp(e::Eff,a) = () ~e~> a;

sig get : () {Get:s|_}-> s
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}-> ()
fun put(st) {do Put(st)}

sig count : (Comp({Get:Int,Put:(Int) {}-> () |_}, Int))
fun count() {
  var n = get();
  if (n == 0) 0
  else { put(n-1); count() }
}

fun evalState(f) {
  shallowhandle(f()) {
    case Return(x) -> fun(_) { x }
    case Get(resume) ->
       var resume0 = fun(x) {
          evalState(fun() { resume(x) })
       };
       fun(st) { resume0(st)(st) }
    case Put(p, resume) ->
       var resume0 = fun(x) {
          evalState(fun() { resume(x) })
       };
       fun(st) { resume0(())(p) }
  }
}

benchmark("Deep countdown (encoded)", (==), 0, fun() { evalState(count)(1000000) })
